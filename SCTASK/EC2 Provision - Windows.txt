1. Get Ticket

Pre Execution:

Process.url = "https://biogen.service-now.com/api/now/table/sc_task?number="+Process.Number

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=0;
  Process.ReturnMessage="Ticket details fetched successfully"
  Process.Output=Process[OpName].HTTPResponseContent
  
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Failure fetching ticket details"
}

2.Second Operator (Read)

Inline:

var str =Process.Output
var start=str.indexOf('[')+2;
var end=str.indexOf(']')-1;
var res = str.substring(start,end);
var out1= res.split(',');
for(var i=0;i < out1.length;i++)
{
  out1[i]=out1[i].replace(/\"/g,"");
  if(out1[i].indexOf('active')>=0)
  {Process.active=(out1[i].split(':'))[1]}
  else if(out1[i].indexOf('sys_id')>=0)
  {Process.Sys_Id=(out1[i].split(':'))[1]}
  else if(out1[i].indexOf('description')>=0)
  {Process.description=(out1[i].split(':'))[1]}
  else if(out1[i].indexOf('state')>=0)
  {Process.state=(out1[i].split(':'))[1]}
  out1[i]=(out1[i].split(':'))[1]
}

Post Execution:

if(Process.active=='true')
{
  Process.ReturnCode=0;
  Process.ReturnMessage="Ticket is active.";
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Ticket is inactive.";
}

3.Ticket Update

Pre Execution:

Process.putURL="https://biogen.service-now.com/api/now/table/sc_task/"+Process.Sys_Id+""
Process.payload = "<request><entry><assigned_to>d2f5f34bdb5efb8036c73c9b7c961900</assigned_to><work_notes>Automation Acknowledged. Ref ID:"+ Process.RuntimeROID+"</work_notes><state>2</state></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  if(Process[OpName].HTTPResponseContent.indexOf("state\":\"")>=0)
  {
	Process.ReturnCode=0;
	Process.ReturnMessage="Ticket updated successfully ";
  }
  else
  {
	Process.ReturnCode=-1;
	Process.ReturnMessage="Error occurred while  updating ticket";
  }
}
else
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Failure occurred while updating ticket."
}

4.Script

Inline:

param(
[String]$inpList,
[String]$Number
)

Test-Connection -ComputerName $inpList -Quiet

$path="D:\EC2_Provision_Log"
$path1="D:\EC2_Provision_Log\log.txt"
function day{
    Get-Date -Format "ddd_dd_MMM_yyyy_HH_mm_ss"
}
$line=@()
if(Test-Path –path $path)
    {
     Write-Host "Folder is available"

    }
    else
    {
	New-Item $path -ItemType Directory
    }
     if(Test-Path –path $path1){
     Write-Host "Log file available"}
    else {
    New-Item $path -ItemType File -Name log.txt
     $line +="Creating log file" 
	 }
$line += "Script Started Execution at :$(day)" 
$line += "Server qualification for $inpList" 
$line += "The Ticket assigned $Number for the server" 
 $line +="Script Ended Execution at :$(day)"
 $line | Out-File -FilePath $path1 -Append -Force


Post Execution:

if(Process.Ping_check.scriptOutput.indexOf("True")>=0)
{
  Process.ReturnCode=0
  Process.ReturnMessage="Connection to Target Server " +Process.inpList+" is reachable"
}
else if(Process.Ping_check.scriptOutput.indexOf("False")>=0)
{
  Process.ReturnCode=2
  Process.ReturnMessage="Connection to Target Server " +Process.inpList+" is unreachable"
}
else
{
Process.ReturnCode=-1
Process.ReturnMessage = "Connection to reach the server" +Process.inpList+" is failed."
}


5.Ticket Update

Success 

Pre Execution:

Process.putURL="https://biogen.service-now.com/api/now/table/sc_task/"+Process.Sys_Id+""
Process.payload = "<request><entry><state>2</state><work_notes>Target server  "+Process.inpList+" is reachable</work_notes></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Ticket worknotes updated successfully"
  Process.Output=Process[OpName].HTTPResponseContent
  
}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Failure updating ticket details"
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
}

Failure

Pre Execution:

Process.putURL="https://biogen.service-now.com/api/now/table/sc_task/"+Process.Sys_Id+""
//Process.payload = "<request><entry><state>1</state><assignment_group>d32d41c5dbe73e00d41dd3cb5e96194f</assignment_group><work_notes>"+Process.ReturnMessage+ " , Hence Routing the ticket to Windows Queue.</work_notes></entry></request>"
Process.payload = "<request><entry><state>7</state><work_notes>"+Process.ReturnMessage+ "</work_notes></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Successfully Transferred, Issuse not resolved"
  Process.Output=Process[OpName].HTTPResponseContent
  
}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Failure updating ticket details"
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
}

6.Script

Inline:

param(
[String]$SerUser,
[String]$SerPass,
[String]$CSV,
[String]$Number
)

#Set-StrictMode -Version Latest; 
$ErrorActionPreference = 'Stop'; $ScriptVersion = '2.0'; $datestart=(Get-Date)
$password = ConvertTo-SecureString $SerPass -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential ($SerUser, $password)


#$SName = $MyInvocation.MyCommand.Name; $SFN =  $MyInvocation.MyCommand.Definition ; $SPath = Split-Path -parent $SFN

$SPath="D:\VAL\EC2_Windows"
$SPath1="D:\VAL\EC2_Windows\output\$Number"
$SName = $MyInvocation.MyCommand.Name;
 If(!(test-path $SPath1))
    {
          New-Item -ItemType Directory -Force -Path $SPath1
    }
    else{
         if( Get-ChildItem $SPath1)
		 { Get-ChildItem $SPath1 | Remove-Item }
    }

$msg1 = '***********************************************************************************************************************'
#######################################################################################################################
# Create folders for log and output, define log and output file names
'_old','log','output','input' |%{if (!(Test-Path "$SPath\$_")) {md "$SPath\$_" >$null}}
[string]$LogFile = "$SPath\log\$SName.$(get-date -uformat "%Y-%m-%d_%H-%M-%S").log"
#######################################################################################################################
function flog ($msg){write "$(get-date -format yyyy-MM-dd_HH:mm:ss) $msg"  | Out-File $LogFile -Append}
#######################################################################################################################
function gw ($m){write-host -F green $m};function cw ($m){write-host -F cyan $m};function rw ($m){write-host -F red $m}
#######################################################################################################################
function header {$a = "--------------------------------------------------------------------------------" ; flog $a ; 
    flog $a ; flog "	Script name  :   $SName" ; flog "	Script ver.  :   $ScriptVersion"
    flog "	User         :   $env:username"	
	flog "	Server name  :   $env:computername" ; flog "	Client name  :   $env:CLIENTNAME" ; flog $a ; flog $a}
#######################################################################################################################
function EndScript {flog "" ; flog "Script execution has finished" ; flog "" ; 
$dateend = (Get-date) - $datestart
    [string]$h = $dateend | select Days,Hours,Minutes,Seconds,Milliseconds ; 
    $h = $h.Replace('@{','')
    $h = $h.Replace('}','') ; flog "Script runtime: $h"
    flog "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx END OF FILE xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
	exit }
#######################################################################################################################
cls; header; $i = 0

#$CSVFile = "$SPath\input\input.csv"; 
$htop = "D:\wkhtmltopdf\bin\wkhtmltopdf.exe"
If(!(test-path $htop)){$m = "FAIL : Wkhtmltopdf missing. Check for: $htop . The script ends."; rw $m; flog $m; EndScript}
#If(!(test-path $CSVFile)){$m = "FAIL : Input.csv missing. Check for: $CSVFile .The script ends";rw $m;flog $m; EndScript}

#$CSV=Import-Csv $CSVFile; $CSVcount = ($CSV | Measure-Object).Count
cw 'Provide Domain Admin credentials';
#[PSCredential]$cred = (Get-Credential);
cw $msg1


foreach($item in $CSV){
	if(!([string]::IsNullOrWhiteSpace($item))){
		[string]$cn = $item; $i++
		$startdate = get-date -format yyyy-MM-dd_HH_mm_ss; $SStart = get-date
		#$m = "Starting IVOV task for $cn - $i of $CSVcount"; cw $m; flog $m

		
		if(Test-Connection -cn $CN -Count 1 -ea 0 -quiet){$m = "$cn : is ONLINE"; gw $m; flog $m}
		else {$m = "FAIL : Connection test. Server $cn skipped. See logfile for details."
			rw $m; rw ''; flog $m; cw $msg1; flog $msg1; continue}
		
		try {
			$ncs = $null; $ncs = New-CimSession -OperationTimeoutSec 300 -cn $cn -Credential $cred
			$m = "$cn : CimSession created"; gw $m; flog $m
		}
		catch {$m = "FAIL : CimSession creation. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}
		
		$tws = $null; 
<#try {icm $cn {$h}}
		catch {$m = "FAIL : PSSession creation. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}#>
		
		$ScriptBlockR1 = {$event = Get-WinEvent -ListLog System | select LogName,RecordCount,IsEnabled; return $event}
		$ScriptBlockR2 = {$a = get-date -Format "dd-MMM-yyyy HHmm"; $b = "$([System.TimeZone]::CurrentTimeZone.StandardName)"; $rTime = "$a | $b"; return $rTime}
		try{
#$s = New-Pssession -cn $cn
			$Log = $null; $Log = Invoke-Command $cn -Credential $cred $ScriptBlockR1
			if([string]::IsNullOrWhiteSpace($Log.IsEnabled)){
				$m = "FAIL : Remote Log Event retrieval. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
				cw $msg1; flog $msg1; continue
			}
			
			$rTime = $null; $rTime = Invoke-Command $cn -Credential $cred $ScriptBlockR2			
			if([string]::IsNullOrWhiteSpace($rTime)){
				$m = "FAIL : Remote Time and Timezone retrieval. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
				cw $msg1; flog $msg1; continue
			}			
			#Remove-PSSession $s
		}
		catch{$m = "FAIL : Remote Log Event, Time and Timezone retrieval. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue}

		$IVOVStatus = $null; $valueHash = @{}; $passHash = @{}
		$procArchi=@("x86","MIPS","Alpha","PowerPC","5","ARM","ia64","Itanuium","Itanium","x64")			
			
		try {	
			$OsInfo = $null; $OsInfo = gcim -ClassName Win32_OperatingSystem -CimSession $ncs
		
			$CsInfo = $null; $CsInfo = gcim -ClassName Win32_ComputerSystem -CimSession $ncs |
						   Select-Object Name,Manufacturer,Model,
									@{Name='PhysicalProcessors';Expression={$_.NumberOfProcessors}},
									@{Name='LogicalProcessors';Expression={$_.NumberOfLogicalProcessors}},
									@{Name='TotalPhysicalMemory';Expression={
										$tpm = $_.TotalPhysicalMemory/1GB;
										"{0:F0}" -f $tpm
									}},
									DnsHostName,Domain,Domainrole
		
			$Procinfo = $null; $Procinfo = gcim -ClassName Win32_Processor -CimSession $ncs | Select-Object  NumberOfCores,MaxClockSpeed,Architecture, @{N='Config';E={""+$_.NumberOfCores+" cores - "+($_.MaxClockSpeed/1000)+" GHz "+$procArchi[$_.Architecture]}}
		
			$DiskInfo = $null; $DiskInfo = gcim  -CimSession $ncs -ClassName  Win32_logicaldisk -Filter "DriveType = '3'" | sort DeviceID |select -Property DeviceID,@{L="DiskSize";E={"{0:N0}" -f ($_.Size/1GB)}}
			$m = "$cn : Data collection region PDS001 - PDS004 successful"; gw $m; flog $m 
		}
		catch{$m = "FAIL : Requirement PDS004. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}

		#region PDS-001
		try{
			$valueHash["PDS-001"]=""+$OsInfo.Caption+" "+ $OsInfo.OSArchitecture
			if([System.Version]::Parse($OsInfo.Version) -gt '6.1.0'){
				$passHash["PDS-001"]="<b style='color:#20A608'>PASS</b>"
			}
			else{
				$passHash["PDS-001"]="<b style='color:#FF3C33'>FAIL</b>"
				$m = 'FAIL : [System.Version]::Parse($OsInfo.Version) -gt 6.1.0'; rw $m; flog $m
			}
		}
		catch {
			$m = "FAIL : Data collection PDS001 - PDS004. Server $cn skipped. See logfile for details.";rw $m;rw '';flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}
		#endregion PDS-001
		
		#region PDS-002
		try{
			$valueHash["PDS-002"]=""
			$passHash["PDS-002"]="<b style='color:#20A608'>PASS</b>"
			ForEach($cp in $Procinfo)
			{
				$valueHash["PDS-002"]+=$cp.Config+"</br>"
				if(-not($cp.NumberOfCores -ge 1))
				   {
					$passHash["PDS-002"]="<b style='color:#FF3C33'>FAIL</b>"
					$m = 'FAIL : $cp.NumberOfCores -ge 1'; rw $m; flog $m
					}
			}
			
		}
		catch{$m = "FAIL : Requirement PDS002. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}
		#endregion PDS-002

		#region PDS-003
		try{
			$valueHash["PDS-003"]=""+[math]::Round($CsInfo.TotalPhysicalMemory,3)
			if([int]$CsInfo.TotalPhysicalMemory -ge 1){
				$passHash["PDS-003"]="<b style='color:#20A608'>PASS</b>"
			}
			else{
				$passHash["PDS-003"]="<b style='color:#FF3C33'>FAIL</b>"
				$m = 'FAIL : [int]$CsInfo.TotalPhysicalMemory -ge 1'; rw $m; flog $m
			}
		}
		catch{$m = "FAIL : Requirement PDS003. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}
		#endregion PDS-003

		#region PDS-004
		try{
			$OSDisk=0
			$valueHash["PDS-004"]=""
			$passHash["PDS-004"]="<b style='color:#FF3C33'>FAIL</b>"
			
			foreach($DDevice in $DiskInfo){
				if($DDevice.DeviceID -eq 'C:'){
					$a = $null; [int]$a = $DDevice.DiskSize
					if($a -ge 10){
						$passHash["PDS-004"]="<b style='color:#20A608'>PASS</b>"
					}
					else {$passHash["PDS-004"]="<b style='color:#FF3C33'>FAIL</b>"}
				}
				$valueHash["PDS-004"]+=$DDevice.DeviceID+" -> "+$DDevice.DiskSize+" GB<br>"
			}
		}
		catch{$m = "FAIL : Requirement PDS004. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}
		#endregion PDS-004

		#region PDS-005
		try{
			if($Log.IsEnabled -eq 'True'){$valueHash["PDS-005"]="<b>System Log Details </b><br/><b>Log Name: </b>"+
				$Log.LogName+"<br/><b>Log Count: </b>"+$Log.RecordCount+"<br/><b>Log Enabled: </b>"+$Log.IsEnabled+"<br/><b>"
				$passHash["PDS-005"]="<b style='color:#20A608'>PASS</b>";$m = "$cn : Data collection region PDS005 successful"; gw $m; flog $m}
			else {$passHash["PDS-005"]="<b style='color:#FF3C33'>FAIL</b>";	$m = "$cn : Data collection region PDS005 NOT successful"; rw $m; flog $m}					
			}
		catch{$m = "FAIL : Requirement PDS005. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}
		
		#endregion PDS-005
		
		#region PDS-006


       

		try{
			$rdsCHK = $null; $rdsCHK = gcim -CimSession $ncs -ClassName RSOP_UserPrivilegeRight -namespace root\rsop\computer |
			?{$_.UserRight -eq "SeRemoteInteractiveLogonRight" -and $_.precedence -eq 1} | Select -expand AccountList

            if(!([string]::IsNullOrWhiteSpace($rdsCHK))){
		        $valueHash["PDS-006"]="<b>Option A: Allow log on through Remote Desktop Services: </b><br/>"+$rdsCHK
		        if($rdsCHK -match "Administrators"){$passHash["PDS-006"]="<b style='color:#20A608'>PASS</b>"}
		        else{$passHash["PDS-006"]="<b style='color:#FF3C33'>FAIL</b>"}
            }			
		}
		catch{$m = "FAIL : Requirement PDS006a. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}
		
		if([string]::IsNullOrWhiteSpace($rdsCHK)){
			try{
				[string]$rdsCHK = $null

				$g1 = [ADSI]("WinNT://$cn,Computer"); $gm1 = $g1.PSBase.Children.Find('Administrators','Group')
                [string]$gs1 = $gm1 | select -expand Name 

			    $g2 = [ADSI]("WinNT://$cn,Computer"); $gm2 = $g2.PSBase.Children.Find('Remote Desktop Users','Group')
                [string]$gs2 = $gm2 | select -expand Name
			
              
                $rdsCHK = "$gs1, $gs2"


		        $valueHash["PDS-006"]="<b>Option B: Authorized to access the server: </b><br/>"+$rdsCHK
		        if($rdsCHK -ne $null){$passHash["PDS-006"]="<b style='color:#20A608'>PASS</b>"}
		        else{$passHash["PDS-006"]="<b style='color:#FF3C33'>FAIL</b>"}
								
			}
			catch{$m = "FAIL : Requirement PDS006b. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
				$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
			}
		}
        $m = "$cn : Data collection region PDS006 successful"; gw $m; flog $m
		
		#endregion PDS-006	
		
		#region PDS-007
		try{
			$TimeS = gcim  -CimSession $ncs -ClassName Win32_Service -Filter 'Name="W32Time"' -Ea 0
			$valueHash["PDS-007"]="<b>Service Name: </b>Windows Time<br><b>State: </b>"+$TimeS.State+ "<br><b>StartMode:</b> "+$TimeS.StartMode
			if($TimeS.State -eq "Running" -And $TimeS.StartMode -eq "Auto"){
				$passHash["PDS-007"]="<b style='color:#20A608'>PASS</b>"
			}
			else{
				$passHash["PDS-007"]="<b style='color:#FF3C33'>FAIL</b>"
			}
			$m = "$cn : Data collection region PDS007 successful"; gw $m; flog $m
		}
		catch{$m = "FAIL : Requirement PDS007. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}
		#endregion PDS-007	
		
		#region PDS-008
		try{
			$avService = $avS = $avoS = $null
			$avService = gcim -KeyOnly -OperationTimeoutSec 300 -CimSession $ncs -ClassName Win32_Service -Filter "(StartMode LIKE 'Auto' and State LIKE 'Running')" |
			select Name,DisplayName,State,StartMode

			if($avService){
				$m = "$cn : Data collection region PDS008 successful"; gw $m; flog $m
				foreach($item in $avService){
					$j = $item.Name
					if($j -like "*CSFalconService*" -or $j -like "*SepMasterService*" -or $j -like "*masvc*"){
						[string]$avSt = "<b>Antivirus scanner name: </b>"+$item.DisplayName+"<br><b>State: </b>"+$item.State+ "<br><b>StartMode:</b> "+$item.StartMode+"<br>"
						$avS = $true
						$m = "$cn : Antivirus scanner region PDS008 successful"; gw $m; flog $m
						break
					}
				}

				foreach($item in $avService){
					$j = $item.Name
					if($j -like "*Tenable Nessus*" -or $j -like "*xagt*" -or $j -like "*FireEye*" -or $j -like "*QualysAgent*"){
						[string]$avoSt = "<b>Vulnerabilities scanner name: </b>"+$item.DisplayName+"<br><b>State: </b>"+$item.State+ "<br><b>StartMode:</b> "+$item.StartMode
						$avoS = $true
						$m = "$cn : Vulnerabilities scanner region PDS008 successful"; gw $m; flog $m
						break
					}
				}

				if($avS -eq $true -and $avoS -eq $true){
					$valueHash["PDS-008"] = $avSt + $avoSt
					$passHash["PDS-008"]="<b style='color:#20A608'>PASS</b>"
				}
				else {
					$m = "$cn : Antivirus/Vulnerabilities scanner region PDS008 NOT successful"; rw $m; flog $m
					$valueHash["PDS-008"]="NA"
					$passHash["PDS-008"]="<b style='color:#FF3C33'>FAIL</b>"								
				}
			}
			else {
				$m = "$cn : Data collection region PDS008 NOT successful"; rw $m; flog $m
				$valueHash["PDS-008"]="NA"
				$passHash["PDS-008"]="<b style='color:#FF3C33'>FAIL</b>"		
			}
		}
		catch{$m = "FAIL : Requirement PDS008. Server $cn skipped. See logfile for details."; rw $m; rw ''; flog $m
			$Error[0]; flog $($Error[0] | out-string); cw $msg1; flog $msg1; continue
		}
		#endregion PDS-008

		Remove-CimSession $ncs
		
		$HTMLStr=""
		$m = "$cn : start building document"; cw $m; flog $m
		#region htmlBuild
		#region headHTML
		$HtmlStr+="<html><head><style>
		  table.minimalistBlack {
		  border: 2px solid #000000;
		  width: 100%;
		  text-align: left;
		}
		table.minimalistBlack td, table.minimalistBlack th {
		  border: 1px solid #000000;
		  padding: 5px 4px;
		}
		table.minimalistBlack tbody td {
		  font-size: 13px;
		}
		table.minimalistBlack tbody td .failTD {
		  font-weight: bold;
		  color: #FF3C33;
		}
		table.minimalistBlack tbody td .passTD {
		  font-weight: bold;
		  color: #20A608;
		}
		
		table.minimalistBlack thead {
		  background: #CFCFCF;
		  background: -moz-linear-gradient(top, #dbdbdb 0%, #d3d3d3 66%, #CFCFCF 100%);
		  background: -webkit-linear-gradient(top, #dbdbdb 0%, #d3d3d3 66%, #CFCFCF 100%);
		  background: linear-gradient(to bottom, #dbdbdb 0%, #d3d3d3 66%, #CFCFCF 100%);
		  border-bottom: 2px solid #000000;
		}
		table.minimalistBlack thead th {
		  font-size: 15px;
		  font-weight: bold;
		  color: #000000;
		  text-align: center;
		}
		table.minimalistBlack tfoot td {
		  font-size: 14px;
		}</style></head><body><h1><b><center>OS Windows Server Verification</center></b></h1>"
		#endregion headHTML
		#region Baseline
			$HTMLStr+=	"<table width=100% border=1>"
			$HTMLStr+= "<tr> <br> </tr>" 
			$HTMLStr+= "<tr>"
			$HTMLStr+= "<th class=""label"" colspan=2> Server Baseline Information </th>"
			$HTMLStr+= "</tr>"
			$HTMLStr+=	"<tr><td><b> Host Name </b></td>"
			$HTMLStr+=	"<td>" + $CsInfo.Name + "</td></tr>"
			$HTMLStr+=	"<tr><td><b> Server Platform </b></td>"
			$HTMLStr+=	"<td>" + $OsInfo.Caption+" "+ $OsInfo.OSArchitecture + "</td></tr>"
			$HTMLStr+=	"<tr><td><b> Domain </b></td>"
			$HTMLStr+=	"<td>" + $CsInfo.Domain + "</td></tr>"
			$HTMLStr+=	"<tr><td><b> Logon ID used for this test</b></td>"
			$HTMLStr+=	"<td>" + $cred.UserName + "</td></tr>"
			$HTMLStr+=	"<tr><td><b> Report Host Date, Time and Timezone </b></td>"
			$HTMLStr+=	"<td>$rTime</td></tr>"

			$HTMLStr+=	"</table><BR/><BR/>"

		#endregion Baseline
		#region contentHTML
		$HTMLStr+="<table class='minimalistBlack'>
		<thead>
		<tr>
		<th style='width:4%'>PRS ID</th>
		<th style='width:30%'>Design Description</th>
		<th style='width:30%'>Expected Result</th>
		<th style='width:30%'>Actual Result</th>
		<th style='width:6%'>Pass / Fail</th>
		</tr>
		</thead>
		<tbody>
		<TR><TD>PRS-001</TD><TD>Display the following information from the operating system (OS):<br/>OS Edition<br/>CPU<br/>RAM<br/>Hard Disk Storage Space<br/></TD>
<TD>Evidence shows that the operating system specified meets the minimum requirements below. The ability to query the requirements below verifies that the operating system is installed and available. The Result is successful when the requirements below are met or exceeded.<br/>Windows Server 2008</br>1 CPU</br>1 GB RAM</br>10 GB Hard Disk Storage Space
<TD><b>OS Version: </b><br/>"+$valueHash.'PDS-001'+"<br/><b>CPU: </b><br/>"+$valueHash.'PDS-002'+"<b>RAM: </b><br/>"+$valueHash.'PDS-003'+" GB<br/><b>Hard Disk Storage Space: </b><br/>"+$valueHash.'PDS-004'+"</TD>
<TD>"+$passHash.'PDS-001'+"<br/>"+$passHash.'PDS-002'+"<br/>"+$passHash.'PDS-003'+"<br/>"+$passHash.'PDS-004'+"</TD></TR>
<TR><TD>PRS-002</TD><TD>Display the status of the system log (enabled or disabled) and show that the number of events is greater than zero.</TD>
<TD>Evidence shows that the system log status is enabled and the number of events in the system log is greater than zero.</TD>
<TD>"+$valueHash.'PDS-005'+"</TD><TD>"+$passHash.'PDS-005'+"</TD></TR>
<TR><TD>PRS-003</TD><TD>Show how access is restricted on a Windows Server. Access is restricted using security groups.  Use either option a or b and record in the Actual Results which version you used.<br/>
a.) List the value of the group policy setting for 'Allow logon through Remote Desktop Services' to show the list of groups allowed access to a server.<br/>
b.) If this group policy setting is not used then list the default groups which can access the server.  Default groups are 'Administrators' and 'Remote Desktop Users'.</TD>
<TD>Record which option was used (a or b). Evidence attached shows the groups that the server access is restricted to.<br/>
For option a, the Result is successful when at least one security group is present.<br/>
For option b, the Result is successful when 'Administrators' and 'Remote Desktop Users' groups are present.</TD>
<TD>"+$valueHash.'PDS-006'+"</TD><TD>"+$passHash.'PDS-006'+"</TD></TR>
<TR><TD>PRS-004</TD><TD>Display time synchronization to show that the server is configured to use time synchronization from the server domain. Verify that the Time Service is running and set to an automatic start.</TD>
<TD>'Evidence shows that time synchronization is being utilized. The Result is successful when the Time ServiceState is 'Running' and the StartMode is 'Auto'</TD>
<TD>"+$valueHash.'PDS-007'+"</TD><TD>"+$passHash.'PDS-007'+"</TD></TR>
<TR><TD>PRS-005</TD><TD>Display endpoint protection services used to protect servers from security threats and vulnerabilities.  At a minimum show:<br/>
one anti-virus/anti-malware service and<br/>
one vulnerability scanner service<br/>
that is running and set to an automatic start.</TD>
<TD>Evidence shows that endpoint protection services are utilized. The Result is successful when the ServiceState is 'Running' and the StartMode is 'Auto' for:<br/>
at least one anti-virus/security threats scanner service ( CrowdStrike or Symantec or McAfee)<br/>
at least one vulnerabilities scanner service (Tenable Nessus or FireEye or Xagt or Qualys)</TD>
<TD>"+$valueHash.'PDS-008'+"</TD><TD>"+$passHash.'PDS-008'+"</TD></TR>
		</tbody>
		</table></body></html>"
		#endregion contentHTML
		#endregion htmlBuild
		$IVOVStatus= "Success"
		$passHash.Keys | %{if($passHash.Item($_) -like '*FAIL*'){$IVOVStatus= "Failed"}}

		If($IVOVStatus -eq "Success"){
		$m = "$cn : IVOV $IVOVStatus"; gw $m; flog $m
		}
		If($IVOVStatus -eq "Failed"){$m = "$cn : IVOV $IVOVStatus"; rw $m; flog $m}
		#region output
		
		[string]$HTMFile = "$SPath1\"+$cn+"_$startdate.htm"; $HTMLStr | out-file $HTMFile
		[string]$PDFFile = "$SPath1\"+$cn+"_$IVOVStatus"+"_$startdate.pdf";
		
		
		$var = '-q'; 
		try {
			& $htop $var $HTMFile $PDFFile
            
			sleep -seconds 2
			Remove-Item -Path $HTMFile -Force
			$m = "$cn : IVOV saved successfully to: $PDFFile"; gw $m; flog $m		


		}
		catch {
			$m = "$cn : IVOV NOT saved successfully to: $PDFFile"; rw $m; flog $m
			rw $Error[0]
		}
		$m = "$cn : IVOV finished"; cw $m; flog $m
		$SEnd = (get-date) - $SStart | select Hours,Minutes,Seconds
		$m = "$cn : processing time - Hours:"+$SEnd.Hours+"  Minutes:"+$SEnd.Minutes+"  Seconds:"+$SEnd.Seconds; cw $m; flog $m
		$m = $msg1; cw $m; flog $m
		#endregion output
	}
}
EndScript


Post Execution:

if(Process.PDF_File.scriptOutput.indexOf("IVOV Success")>=0)
{
Process.ReturnCode=1
Process.data=Process[OpName].scriptOutput
Process.ReturnMessage = "IVOV Execution Success"
}
else if(Process.PDF_File.scriptOutput.indexOf("IVOV Failed")>=0)
{
  Process.ReturnCode=2
  Process.data=Process[OpName].scriptOutput
  Process.ReturnMessage = "IVOV Execution Failure"
}

else if(Process.PDF_File.scriptOutput.indexOf("IVOV NOT saved successfully")>=0)
{

  Process.ReturnCode=-1
Process.ReturnMessage = "Verification script executed but failed to generate PDF file."

}
else if(Process.PDF_File.scriptOutput.indexOf("Access is denied.")>=0)
{

  Process.ReturnCode=-1
Process.ReturnMessage = "Server is not accessible by "+Process.SerUser+" "

}
else{
 Process.ReturnCode=-1
Process.ReturnMessage = "Error occurred while executing the verification script."
}


Success:

7.Script

Inline:

Param([String]$Number)
$path="D:\VAL\EC2_Windows\output\$Number"
$fname=(Get-ChildItem -Path $path | Select Name).name
$fullpath="$path\$fname"


Write-Host $fname
Write-Host $fullpath


8.Ticket Update (Post)

Pre Execution:

//Process.dat=Process.data.split('\n')

Process.dat=Process.Success.scriptOutput.split('\n')
Process.fname=Process.dat[0]
Process.pdffile=Process.dat[1]
Process.putURL= "https://biogen.service-now.com/api/now/attachment/file?table_name=sc_task&table_sys_id="+Process.Sys_Id+"&file_name="+Process.fname
//Process.payload = "<request><entry><assigned_to>d2f5f34bdb5efb8036c73c9b7c961900</assigned_to><work_notes>Automation Acknowledged. Ref ID:"+ Process.RuntimeROID+"</work_notes><state>2</state></entry></request>"


Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="Created" && Process[OpName].HTTPResponseStatusCode==201 )
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="PDF updated successfully"
  Process.Output=Process[OpName].HTTPResponseContent

}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent

}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Error occurred while uploading PDF file to Service Now. "
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
}

9.Ticket Update

Pre Execution:

Process.putURL="https://biogen.service-now.com/api/now/table/sc_task/"+Process.Sys_Id+""
Process.payload = "<request><entry><work_notes>Script used for component fulfillment is Domain: INFRASTRUCTURE_IT Project: IAO_Platform_Qual Run ID: 550</work_notes><state>3</state></entry></request>"


Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Execution successfull, Issuse resolved"
  Process.Output=Process[OpName].HTTPResponseContent
  
}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Failure updating ticket details"
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
}


Failure

10.Script

Inline:

Param([String]$Number)
$path="D:\VAL\EC2_Windows\output\$Number"
$fname=(Get-ChildItem -Path $path | Select Name).name
$fullpath="$path\$fname"


Write-Host $fname
Write-Host $fullpath


11.Ticket Update (Post)

Pre Execution:

//Process.dat=Process.data.split('\n')

//Process.dat_1=Process.dat .split('\n')



//Process.pdffilename=Process.dat[1]
//Process.fname=Process.dat[2]
Process.dat=Process.Failed.scriptOutput.split('\n')
Process.fname=Process.dat[0]
Process.pdffile=Process.dat[1]
//Process.value="D:\EC2_Provision_Windows\" +Process.dat+
Process.putURL= "https://biogen.service-now.com/api/now/attachment/file?table_name=sc_task&table_sys_id="+Process.Sys_Id+"&file_name="+Process.fname
//Process.payload = "<request><entry><assigned_to>d2f5f34bdb5efb8036c73c9b7c961900</assigned_to><work_notes>Automation Acknowledged. Ref ID:"+ Process.RuntimeROID+"</work_notes><state>2</state></entry></request>"


//$Fileuri = "https://biogendev.service-now.com/api/now/attachment/file?table_name=sc_task&table_sys_id=$Sys_Id&file_name=$fname"

//Invoke-RestMethod -Headers $headers -Method Post -Uri $Fileuri -InFile $pdffilename -UseBasicParsing -ErrorAction Stop
//Write-host "File uploaded successfully "

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="Created" && Process[OpName].HTTPResponseStatusCode==201 )
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="PDF updated successfully"
  Process.Output=Process[OpName].HTTPResponseContent

}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Error occurred while uploading PDF file to Service Now. "
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
}

12.Ticket Update

Pre Execution:

Process.putURL="https://biogen.service-now.com/api/now/table/sc_task/"+Process.Sys_Id+""
Process.payload = "<request><entry><state>7</state><work_notes>Server is not qualified as per Biogen standards. Please refer to the attachment for more details</work_notes></entry></request>"


Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=0;
  Process.ReturnMessage="Successfully Transferred, Issuse not resolved"
  Process.Output=Process[OpName].HTTPResponseContent
  
}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Failure updating ticket details"
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
}

13.Fatal Ticket Update

Pre Execution:

Process.putURL="https://biogen.service-now.com/api/now/table/sc_task/"+Process.Sys_Id+""
Process.FatalErrorPayLoad ="<request><entry><state>7</state><work_notes>"+Process.ReturnMessage+ "</work_notes></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Successfully Transferred, Issuse not resolved"
  Process.Output=Process[OpName].HTTPResponseContent
  
}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
  Process.Output=Process[OpName].HTTPResponseContent
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Failure updating ticket details"
  Process.Fail_Status_Update = Process[OpName].HTTPResponseContent
}

