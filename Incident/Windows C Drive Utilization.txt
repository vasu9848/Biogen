1. Get Ticket

Pre Execution:

var uri="https://"+Process.SnowEnv+".service-now.com/api/now/table/incident?sysparm_fields=number%2Cactive%2Csys_id%2Cincident_state%2Cdescription%2Cassigned_to=SVC-itpam@biogen.com&sysparm_limit=1&number="+Process.incidentNumber
Process.url=uri

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=0;
  Process.ReturnMessage="Ticket details fetched successfully"
  Process.Output=Process[OpName].HTTPResponseContent
  
}
else
{
  Process.ReturnCode=1;
  Process.ReturnMessage="Failure fetching ticket details"
}

2.Second Operator ( Read)

Inline:

var str =Process.Output
var start=str.indexOf('[')+2;
var end=str.indexOf(']')-1;
var res = str.substring(start,end);
var out1= res.split(',');
for(var i=0;i < out1.length;i++)
{
  out1[i]=out1[i].replace(/\"/g,"");
  if(out1[i].indexOf('active')>=0)
  {Process.active=(out1[i].split(':'))[1]}
  else if(out1[i].indexOf('sys_id')>=0)
  {Process.Sys_Id=(out1[i].split(':'))[1]}
  else if(out1[i].indexOf('description')>=0)
  {Process.description=(out1[i].split(':'))[1]}
  else if(out1[i].indexOf('incident_state')>=0)
  {Process.Incidentstate=(out1[i].split(':'))[1]}
  out1[i]=(out1[i].split(':'))[1]
}

Post Execution:

if(Process.active)
{
  Process.ReturnCode=0;
  Process.ReturnMessage="Ticket is active.";
}
else
{
  Process.ReturnCode=1;
  Process.ReturnMessage="Ticket is inactive.";
}

3.Ticket Update

Pre Execution:

Process.payload = "<request><entry><assigned_to>d2f5f34bdb5efb8036c73c9b7c961900</assigned_to><incident_state>2</incident_state><work_notes>Automation Acknowledged. Ref ID:"+ Process.RuntimeROID+"</work_notes></entry></request>"
Process.putURL="https://"+Process.SnowEnv+".service-now.com/api/now/v2/table/incident/"+Process.Sys_Id+"?sysparm_fields=incident_state"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  if(Process[OpName].HTTPResponseContent.indexOf("incident_state\":\"")>=0)
  {
	Process.ReturnCode=0;
	Process.ReturnMessage="Ticket updated successfully ";
  }
  else
  {
	Process.ReturnCode=-1;
	Process.ReturnMessage="Error occurred while updating ticket";
  }
}
else
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Failure occurred while updating ticket"
}

4.Script

Inline:

Test-Connection -ComputerName $args[0] -Quiet

Post Execution:

if(Process.Ping_Check.scriptOutput.indexOf("True")>=0)
{
  Process.ReturnCode=0
}
else if(Process.Ping_Check.scriptOutput.indexOf("False")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Connection to target CI not succesful, routing Incident to “UNIX” Assignment Group"
}
else
{
Process.ReturnCode=1
Process.returnMessage = "Fatal Error"
}

5.Ticket Update

Success:

Pre Execution:

Process.PingPayload="<request><entry><work_notes>Target CI Reached Successfully</work_notes></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  if(Process[OpName].HTTPResponseContent.indexOf("incident_state\":\"")>=0)
  {
	Process.ReturnCode=0;
	Process.ReturnMessage="Ticket updated successfully ";
  }
  else
  {
	Process.ReturnCode=-1;
	Process.ReturnMessage="Error occurred while updating ticket";
  }
}
else
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Failure occurred while updating ticket"
}

Failure:

Pre Execution:

Process.PingFailPayLoad ="<request><entry><assigned_to></assigned_to><work_notes>Target CI is not Reachable</work_notes><assignment_group>d32d41c5dbe73e00d41dd3cb5e96194f</assignment_group></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  if(Process[OpName].HTTPResponseContent.indexOf("incident_state\":\"")>=0)
  {
	Process.ReturnCode=0;
	Process.ReturnMessage="Ticket updated successfully ";
  }
  else
  {
	Process.ReturnCode=-1;
	Process.ReturnMessage="Error occurred while updating ticket";
  }
}
else
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Failure occurred while updating ticket"
}

6.Script

Inline:

param($computer,
$RDPUsername,
$RDPPassword,
$INCNumber)

$pwd = $RDPPassword | ConvertTo-SecureString -AsPlainText -Force
$creds = New-Object pscredential -ArgumentList ($RDPUsername , $pwd)

function timestamp{
    Get-Date -Format "dd_MMM_yyyy_HH:mm:ss tt"
}
$log_path = "D:\Incident\C_Drive\$INCNumber\logs"

$log=@()
$log += "-----------------"
$log += "Script Execution Started at $(timestamp)"
$log += "Service Account used for remediation is Svc-ITPAM"


$filePath= "D:\Incident\C_Drive\$INCNumber\logs"
If(!(test-path $filePath))
{
      New-Item -ItemType Directory -Force -Path $filePath 
}

#### Windows Temp ####

try
{
    $session = New-PSSession -ComputerName $computer -Credential $creds
    $log += "PSSession Established successfully with $computer"
}
catch
{
    $log += "Failed to establish PSSession with $computer"
    Write-Host "Failed to establish PSSession"
}
try
{
        $CdriveObj_before=Get-WmiObject Win32_logicaldisk -ComputerName $computer -Credential $creds -Filter "DeviceID='c:'"
        $size_before = [math]::round($CdriveObj_before.Size/1GB, 0)
        $free_before = [math]::round($CdriveObj_before.FreeSpace/1GB, 0)
        $Percentage_before =[math]::Round((($free_before/$size_before))*100,1)
        
        $log += "Current C Drive Utilization is $Percentage_before"

        if([int]$Percentage_before -le 10)
        {
            Write-Host "Above"
            $log += "C Drive Utilizaiton is above threshold limit"
"What is the Issue : C: drive free space is less than the threshold.

C Drive Utilization was $Percentage_before

Cause of the issue or Analysis:  Windows\temp, \windows\softwaredistribution, \windows\users\, RecycleBin might be using more space"  | Out-File "D:\Incident\C_Drive\$INCNumber\logs\close_notes.txt"
        }
        else
        {
            Write-Host "Below"
            $log += "C Drive Utilizaiton is below threshold limit"

"What is the Issue : C: drive free space is less than the threshold.

Cause of the issue or Analysis:  Windows\temp, \windows\softwaredistribution, \windows\users\, RecycleBin might be using more space.

Action taken : None

Current status : Now the free space is $Percentage_before %, Hence resolving the incident"   | Out-File "D:\Incident\C_Drive\$INCNumber\logs\close_notes.txt"
        }
}
catch
{
    Write-Host "Unable to fetch the C Drive space"
    $log += "Unable to fetch the C Drive space"
}

$log += $temp_Content 

$log += "Script Execution Ends $(timestamp)"
$log += "-----------------"

$log | Add-Content "$log_path\log.txt"

Post Execution:

if(Process[OpName].scriptOutput.indexOf("Below")>=0)
{
  Process.ReturnCode=3
  Process.Unitilzation="Low"
  Process.ReturnMessage="The C Drive utilised is below threshold, Resolving the Ticket"
}
else if(Process[OpName].scriptOutput.indexOf("Above")>=0)
{
  Process.ReturnCode=5
  Process.ReturnMessage ="The C Drive utilization is above the threshold limit"
}
else if(Process[OpName].scriptOutput.indexOf("Unable to fetch the C Drive space")>=0)
{
  Process.ReturnCode=7
  Process.ReturnMessage="Unable to fetch the C Drive space"
}
else
{
Process.ReturnCode=-1
Process.returnMessage = "Fatal Error"
}

7.Ticket Update

Pre Execution:

Process.CPUHighPayLoad= "<request><entry><work_notes>"+Process.ReturnMessage+"</work_notes></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  if(Process[OpName].HTTPResponseContent.indexOf("incident_state\":\"")>=0)
  {
	Process.ReturnCode=0;
	Process.ReturnMessage="Ticket updated successfully ";
  }
  else
  {
	Process.ReturnCode=-1;
	Process.ReturnMessage="Error occurred while updating ticket";
  }
}
else
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Failure occurred while updating ticket"
}

8.Script

Inline:

param($computer,
$RDPUsername,
$RDPPassword,
$INCNumber)

$pwd = $RDPPassword | ConvertTo-SecureString -AsPlainText -Force
$creds = New-Object pscredential -ArgumentList ($RDPUsername , $pwd)

function timestamp{
    Get-Date -Format "dd_MMM_yyyy_HH:mm:ss tt"
}

$log_path = "D:\Incident\C_Drive\$INCNumber\logs"

$log=@()
$log += "-----------------"
$log += "Script Execution Started at $(timestamp)"
$log += "Service Account used for remediation is Svc-ITPAM"


$filePath= "D:\Incident\C_Drive\$INCNumber\logs"
If(!(test-path $filePath))
{
      New-Item -ItemType Directory -Force -Path $filePath 
}

#### Windows Temp ####

try
{
    $session = New-PSSession -ComputerName $computer -Credential $creds
    $log += "PSSession Established successfully with $computer"
}
catch
{
    $log += "Failed to establish PSSession with $computer"
    Write-Host "Failed to establish PSSession"
}
try
{
    Invoke-Command -Session $session -ScriptBlock { 
        Param($INCNumber)

        $filePath="D:\Incident\C_Drive\$INCNumber\logs"
        If(!(test-path $filePath))
        {
              New-Item -ItemType Directory -Force -Path $filePath 
        }

        $CdriveObj_before=Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_before = [math]::round($CdriveObj_before.Size/1GB, 0)
        $free_before = [math]::round($CdriveObj_before.FreeSpace/1GB, 0)
        $Percentage_before =[math]::Round((($free_before/$size_before))*100,1)
        #Write-Host "`n Disk FreeSpace percentage Before wintemp cleanup :$Percentage_before % `n "
        
        $windowsTemp = "C:\Windows\Temp\*"
        $temp_files = Get-ChildItem -Path $windowsTemp -Recurse
        $temp_files | Out-File -FilePath "D:\Incident\C_Drive\$INCNumber\logs\temp.txt" -Force
        foreach($temp_file in $temp_files)
        {
            Remove-Item -Path $temp_file.fullname -Recurse -Force -ErrorAction SilentlyContinue
        }

        $CdriveObj_after =Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_after = [math]::round($CdriveObj_after.Size/1GB, 0)
        $free_after = [math]::round($CdriveObj_after.FreeSpace/1GB, 0)
        $Percentage_after =[math]::Round((($free_after/$size_after))*100,1)
        #Write-Host "`n Disk FreeSpace percentage after wintemp cleanup :$Percentage_after % `n "
        
        "Disk FreeSpace percentage Before wintemp cleanup :$Percentage_before %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt" 
        "Disk FreeSpace percentage after wintemp cleanup: $Percentage_after %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt" -Append

    } -ArgumentList $INCNumber
    $log += "Temp Files Cleared Successfully"
    Write-Host "Temp Files Cleared Successfully"
	"Temp Files Cleared Successfully" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\close_notes.txt" -Append
}
catch
{
    $log += "Failed to Clear Windows Temp Files"
    Write-Host "Failed to Clear Windows Temp Files"
}

Copy-Item  -FromSession $session -Path "$filepath\temp.txt" -Destination "$filePath\temp.txt"
Copy-Item  -FromSession $session -Path "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt" -Destination "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"

$temp_Content = Get-Content "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"

$log += $temp_Content 

$log += "Script Execution Ends $(timestamp)"
$log += "-----------------"

$log | Add-Content "$log_path\log.txt"


Post Execution:

if(Process[OpName].scriptOutput.indexOf("Temp Files Cleared Successfully")>=0)
{
  Process.ReturnCode=5
  Process.ReturnMessage ="Temp Files Cleared Successfully"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to establish PSSession")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to establish PSSession"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to Clear Windows Temp Files")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to Clear Windows Temp Files"
}
else
{
Process.ReturnCode=-1
Process.returnMessage = "Fatal Error"
}


9.Script

Inline:

param($computer,
$RDPUsername,
$RDPPassword,
$INCNumber)

$pwd = $RDPPassword | ConvertTo-SecureString -AsPlainText -Force
$creds = New-Object pscredential -ArgumentList ($RDPUsername , $pwd)

function timestamp{
    Get-Date -Format "dd_MMM_yyyy_HH:mm:ss tt"
}

$log_path = "D:\Incident\C_Drive\$INCNumber\logs"

$log=@()
$log += "-----------------"
$log += "Script Execution Started at $(timestamp)"
$log += "Service Account used for remediation is Svc-ITPAM"

If(!(test-path $log_path))
{
      New-Item -ItemType Directory -Force -Path $log_path 
}

#### Windows Temp ####

try
{
    $session = New-PSSession -ComputerName $computer -Credential $creds
    $log += "PSSession Established successfully with $computer"
}
catch
{
    $log += "Failed to establish PSSession with $computer"
    Write-Host "Failed to establish PSSession"
}

try
{
    Invoke-Command -Session $session -ScriptBlock {Get-Service -Name WUAUSERV | Stop-Service}
    $log += "SWD Service Stopped Successfully"
}
catch
{
$log += "Failed to Stop SWD Service"
Write-Host "Failed to Stop SWD Service"
}

try
{
    Invoke-Command -Session $session -ScriptBlock { 
        Param($INCNumber)

        $filePath="D:\Incident\C_Drive\$INCNumber\logs"
        If(!(test-path $filePath))
        {
              New-Item -ItemType Directory -Force -Path $filePath 
        }

        $CdriveObj_before=Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_before = [math]::round($CdriveObj_before.Size/1GB, 0)
        $free_before = [math]::round($CdriveObj_before.FreeSpace/1GB, 0)
        $Percentage_before =[math]::Round((($free_before/$size_before))*100,1)
        #Write-Host "`n Disk FreeSpace percentage Before wintemp cleanup :$Percentage_before % `n "
        
        $swdist = "C:\Windows\SoftwareDistribution"
        $swdistfiles = Get-ChildItem -Path $swdist -Recurse 
        $swdistfiles | Out-File -FilePath "D:\Incident\C_Drive\$INCNumber\logs\swdist.txt" -Force
        foreach($swdistfile in $swdistfiles)
        {
            #Remove-Item -Path $swdistfile.fullname -Recurse -Force -ErrorAction SilentlyContinue
        }
    
        $CdriveObj_after =Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_after = [math]::round($CdriveObj_before.Size/1GB, 0)
        $free_after = [math]::round($CdriveObj_before.FreeSpace/1GB, 0)
        $Percentage_after =[math]::Round((($free_before/$size_before))*100,1)
        #Write-Host "`n Disk FreeSpace percentage after wintemp cleanup :$Percentage_after % `n "
        
        "Disk FreeSpace percentage Before SWD cleanup :$Percentage_before %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"
        "Disk FreeSpace percentage after SWD cleanup: $Percentage_after %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt" -Append

    } -ArgumentList $INCNumber
    $log += "Software Distribution Files Cleared Successfully"
    Write-Host "Software Distribution Files Cleared Successfully"
	"Software Distribution Files Cleared Successfully" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\close_notes.txt" -Append
}
catch
{
    $log += "Failed to Clear Windows Software Distribution Files"
    Write-Host "Failed to Clear Windows Software Distribution Files"
}

try
{
    Invoke-Command -Session $session -ScriptBlock {Get-Service -Name WUAUSERV | Start-Service}
    $log += "SWD Service Stopped Successfully"
}
catch
{
$log += "Failed to Start SWD Service"
Write-Host "Failed to Start SWD Service"
}

Copy-Item  -FromSession $session -Path "$log_path\swdist.txt" -Destination "$log_path\swdist.txt"
Copy-Item  -FromSession $session -Path "$log_path\Drive_Space.txt" -Destination "$log_path\Drive_Space.txt"

$temp_Content = Get-Content "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"

$log += $temp_Content 

$log += "Script Execution Ends $(timestamp)"
$log += "-----------------"

$log | Add-Content "$log_path\log.txt"


Post Execution:

if(Process[OpName].scriptOutput.indexOf("Software Distribution Files Cleared Successfully")>=0)
{
  Process.ReturnCode=5
  Process.ReturnMessage ="Software Distribution Files Cleared Successfully"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to establish PSSession")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to establish PSSession"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to Stop SWD Service")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to Stop SWD Service"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to Clear Windows Software Distribution Files")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to Clear Windows Software Distribution Files"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to Start SWD Service")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to Start SWD Service"
}
else
{
Process.ReturnCode=-1
Process.returnMessage = "Fatal Error"
}


10.Script

Inline:

param($computer,
$RDPUsername,
$RDPPassword,
$INCNumber)

$pwd = $RDPPassword | ConvertTo-SecureString -AsPlainText -Force
$creds = New-Object pscredential -ArgumentList ($RDPUsername , $pwd)

function timestamp{
    Get-Date -Format "dd_MMM_yyyy_HH:mm:ss tt"
}

$log_path = "D:\Incident\C_Drive\$INCNumber\logs"

$log=@()
$log += "-----------------"
$log += "Script Execution Started at $(timestamp)"
$log += "Service Account used for remediation is Svc-ITPAM"


$filePath= "D:\Incident\C_Drive\$INCNumber\logs"
If(!(test-path $filePath))
{
      New-Item -ItemType Directory -Force -Path $filePath 
}

#### Windows Temp ####

try
{
    $session = New-PSSession -ComputerName $computer -Credential $creds
    $log += "PSSession Established successfully with $computer"
}
catch
{
    $log += "Failed to establish PSSession with $computer"
    Write-Host "Failed to establish PSSession"
}
try
{
    Invoke-Command -Session $session -ScriptBlock { 
        Param($INCNumber)

        $filePath="D:\Incident\C_Drive\$INCNumber\logs"
        If(!(test-path $filePath))
        {
              New-Item -ItemType Directory -Force -Path $filePath 
        }

        $CdriveObj_before=Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_before = [math]::round($CdriveObj_before.Size/1GB, 0)
        $free_before = [math]::round($CdriveObj_before.FreeSpace/1GB, 0)
        $Percentage_before =[math]::Round((($free_before/$size_before))*100,1)
        #Write-Host "`n Disk FreeSpace percentage Before wintemp cleanup :$Percentage_before % `n "
        
        $recy='C:\$Recycle.Bin'
        $fold= (Get-ChildItem $recy -Force -Recurse)
        $fold | Out-File -FilePath "D:\Incident\C_Drive\$INCNumber\logs\recycle.txt" -Force
        foreach($file in $fold)
        {
            Remove-Item -Path $file.fullname -Recurse -Force -ErrorAction SilentlyContinue
        }
        
        $CdriveObj_after =Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_after = [math]::round($CdriveObj_after.Size/1GB, 0)
        $free_after = [math]::round($CdriveObj_after.FreeSpace/1GB, 0)
        $Percentage_after =[math]::Round((($free_after/$size_after))*100,1)
        #Write-Host "`n Disk FreeSpace percentage after wintemp cleanup :$Percentage_after % `n "
        
        "Disk FreeSpace percentage Before RecycleBin cleanup :$Percentage_before %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt" 
        "Disk FreeSpace percentage after RecycleBin cleanup: $Percentage_after %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt" -Append

    } -ArgumentList $INCNumber
    $log += "Recycle Bin Cleared Successfully"
    Write-Host "Recycle Bin Cleared Successfully"
	#"Recycle Bin Cleared Successfully" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\close_notes.txt" -Append
}
catch
{
    $log += "Failed to Clear Recycle Bin Files"
    Write-Host "Failed to Clear Recycle Bin Files"
}

Copy-Item  -FromSession $session -Path "$log_path\recycle.txt" -Destination "$log_path\recycle.txt"
Copy-Item  -FromSession $session -Path "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt" -Destination "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"

$temp_Content = Get-Content "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"

$log += $temp_Content 

$log += "Script Execution Ends $(timestamp)"
$log += "-----------------"

$log | Add-Content "$log_path\log.txt"


Post Execution:

if(Process[OpName].scriptOutput.indexOf("Recycle Bin Cleared Successfully")>=0)
{
  Process.ReturnCode=5
  Process.ReturnMessage ="Recycle Bin Cleared Successfully"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to establish PSSession")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to establish PSSession"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to Clear Recycle Bin Files")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to Clear Recycle Bin Files"
}

else
{
Process.ReturnCode=-1
Process.returnMessage = "Fatal Error"
}

11.Script

Inline:

param($computer,
$RDPUsername,
$RDPPassword,
$INCNumber)

$pwd = $RDPPassword | ConvertTo-SecureString -AsPlainText -Force
$creds = New-Object pscredential -ArgumentList ($RDPUsername , $pwd)

function timestamp{
    Get-Date -Format "dd_MMM_yyyy_HH:mm:ss tt"
}

$log_path = "D:\Incident\C_Drive\$INCNumber\logs"

$log=@()
$log += "-----------------"
$log += "Script Execution Started at $(timestamp)"
$log += "Service Account used for remediation is Svc-ITPAM"

If(!(test-path $log_path))
{
      New-Item -ItemType Directory -Force -Path $log_path 
}

#### Windows Temp ####

try
{
    $session = New-PSSession -ComputerName $computer -Credential $creds
    $log += "PSSession Established successfully with $computer"
}
catch
{
    $log += "Failed to establish PSSession with $computer"
    Write-Host "Failed to establish PSSession"
}
try
{
    Invoke-Command -Session $session -ScriptBlock { 
        Param($INCNumber)

        $filePath="D:\Incident\C_Drive\$INCNumber\logs"
        If(!(test-path $filePath))
        {
              New-Item -ItemType Directory -Force -Path $filePath 
        }

        $CdriveObj_before=Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_before = [math]::round($CdriveObj_before.Size/1GB, 0)
        $free_before = [math]::round($CdriveObj_before.FreeSpace/1GB, 0)
        $Percentage_before =[math]::Round((($free_before/$size_before))*100,1)
        #Write-Host "`n Disk FreeSpace percentage Before wintemp cleanup :$Percentage_before % `n "
        
        $ccmcache = "C:\Windows\ccmcache"
        $cache_files = Get-ChildItem -Path $ccmcache -Recurse
        $cache_files | Out-File -FilePath "D:\Incident\C_Drive\$INCNumber\logs\ccmcache.txt" -Force
        foreach($cache_file in $cache_files)
        {
            Remove-Item -Path $cache_file.fullname -Recurse -Force -ErrorAction SilentlyContinue
        }
    
        $CdriveObj_after =Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_after = [math]::round($CdriveObj_after.Size/1GB, 0)
        $free_after = [math]::round($CdriveObj_after.FreeSpace/1GB, 0)
        $Percentage_after =[math]::Round((($free_after/$size_after))*100,1)
        #Write-Host "`n Disk FreeSpace percentage after wintemp cleanup :$Percentage_after % `n "
        
        "Disk FreeSpace percentage Before CCMCache cleanup :$Percentage_before %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"
        "Disk FreeSpace percentage after CCMCache cleanup: $Percentage_after %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt" -Append

    } -ArgumentList $INCNumber
    $log += "CCMCache Files Cleared Successfully"
    Write-Host "CCMCache Files Cleared Successfully"
	#"CCMCache Files Cleared Successfully" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\close_notes.txt" -Append
}
catch
{
    $log += "Failed to Clear Windows CCMCache Files"
    Write-Host "Failed to Clear Windows CCMCache Files"
}

Copy-Item  -FromSession $session -Path "$log_path\ccmcache.txt" -Destination "$log_path\ccmcache.txt"
Copy-Item  -FromSession $session -Path "$log_path\Drive_Space.txt" -Destination "$log_path\Drive_Space.txt"

$temp_Content = Get-Content "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"

$log += $temp_Content 

$log += "Script Execution Ends $(timestamp)"
$log += "-----------------"

$log | Add-Content "$log_path\log.txt"


Post Execution:

if(Process[OpName].scriptOutput.indexOf("CCMCache Files Cleared Successfully")>=0)
{
  Process.ReturnCode=5
  Process.ReturnMessage ="CCMCache Files Cleared Successfully"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to establish PSSession")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to establish PSSession"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to Clear Windows CCMCache Files")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to Clear Windows CCMCache Files"
}

else
{
Process.ReturnCode=-1
Process.returnMessage = "Fatal Error"
}


12.Script

Inline:

param($computer,
$RDPUsername,
$RDPPassword,
$INCNumber)


$pwd = $RDPPassword | ConvertTo-SecureString -AsPlainText -Force
$creds = New-Object pscredential -ArgumentList ($RDPUsername , $pwd)

function timestamp{
    Get-Date -Format "dd_MMM_yyyy_HH:mm:ss tt"
}

#$INCNumber = "users"
$log_path = "D:\Incident\C_Drive\$INCNumber\logs"

$log=@()
$log += "-----------------"
$log += "Script Execution Started at $(timestamp)"
$log += "Service Account used for remediation is Svc-ITPAM"

If(!(test-path $log_path))
{
      New-Item -ItemType Directory -Force -Path $log_path 
}

#### Windows Temp ####

try
{
    $session = New-PSSession -ComputerName $computer -Credential $creds
    $log += "PSSession Established successfully with $computer"
}
catch
{
    $log += "Failed to establish PSSession with $computer"
    Write-Host "Failed to establish PSSession"
}
try
{
    Invoke-Command -Session $session -ScriptBlock { 
        Param($INCNumber)

        $filePath="D:\Incident\C_Drive\$INCNumber\logs"
        If(!(test-path $filePath))
        {
              New-Item -ItemType Directory -Force -Path $filePath 
        }

        $CdriveObj_before=Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_before = [math]::round($CdriveObj_before.Size/1GB, 0)
        $free_before = [math]::round($CdriveObj_before.FreeSpace/1GB, 0)
        $Percentage_before =[math]::Round((($free_before/$size_before))*100,1)
        #Write-Host "`n Disk FreeSpace percentage Before wintemp cleanup :$Percentage_before % `n "
        
        $C_Users = "C:\Users\"
        $users = get-childitem $C_Users | ? { $_.lastaccesstime -lt (get-date).AddDays(-90)} | ?{$_.Name -notlike "*svc*"}
        $users | Out-File -FilePath "D:\Incident\C_Drive\$INCNumber\logs\C_Users.txt" -Force
        foreach($user in $users)
        {
            Remove-Item -Path $user.fullname -Recurse -Force -ErrorAction SilentlyContinue
        }
    
        $CdriveObj_after =Get-WmiObject Win32_logicaldisk -Filter "DeviceID='c:'"
        $size_after = [math]::round($CdriveObj_after.Size/1GB, 0)
        $free_after = [math]::round($CdriveObj_after.FreeSpace/1GB, 0)
        $Percentage_after =[math]::Round((($free_after/$size_after))*100,1)
        #Write-Host "`n Disk FreeSpace percentage after wintemp cleanup :$Percentage_after % `n "
        
        "Disk FreeSpace percentage Before Users cleanup :$Percentage_before %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"
        "Disk FreeSpace percentage after Users cleanup: $Percentage_after %" | Out-File "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt" -Append

    } -ArgumentList $INCNumber
    $log += "Inactive Users Files Cleared Successfully"
    Write-Host "Inactive Users Files Cleared Successfully"
}
catch
{
    $log += "Failed to Clear Windows Inactive Users Files"
    Write-Host "Failed to Clear Windows Inactive Users Files"
}

Copy-Item  -FromSession $session -Path "$log_path\C_Users.txt" -Destination "$log_path\C_Users.txt"
Copy-Item  -FromSession $session -Path "$log_path\Drive_Space.txt" -Destination "$log_path\Drive_Space.txt"

$temp_Content = Get-Content "D:\Incident\C_Drive\$INCNumber\logs\Drive_Space.txt"

$log += $temp_Content 

$log += "Script Execution Ends $(timestamp)"
$log += "-----------------"

$log | Add-Content "$log_path\log.txt"


Post Execution:

if(Process[OpName].scriptOutput.indexOf("Inactive Users Files Cleared Successfully")>=0)
{
  Process.ReturnCode=5
  Process.ReturnMessage ="Inactive Users Files Cleared Successfully"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to establish PSSession")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to establish PSSession"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to Clear Windows Inactive Users Files")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to Clear Windows Inactive Users Files"
}

else
{
Process.ReturnCode=-1
Process.returnMessage = "Fatal Error"
}

13.Script

Inline:

param($computer,
$RDPUsername,
$RDPPassword,
$INCNumber)

$pwd = $RDPPassword | ConvertTo-SecureString -AsPlainText -Force
$creds = New-Object pscredential -ArgumentList ($RDPUsername , $pwd)

function timestamp{
    Get-Date -Format "dd_MMM_yyyy_HH:mm:ss tt"
}

$log_path = "D:\Incident\C_Drive\$INCNumber\logs"

$log=@()
$log += "-----------------"
$log += "Script Execution Started at $(timestamp)"
$log += "Service Account used for remediation is Svc-ITPAM"


$filePath= "D:\Incident\C_Drive\$INCNumber\logs"
If(!(test-path $filePath))
{
      New-Item -ItemType Directory -Force -Path $filePath 
}

#### Windows Temp ####

try
{
    $session = New-PSSession -ComputerName $computer -Credential $creds
    $log += "PSSession Established successfully with $computer"
}
catch
{
    $log += "Failed to establish PSSession with $computer"
    Write-Host "Failed to establish PSSession"
}
try
{
        $CdriveObj_before=Get-WmiObject Win32_logicaldisk -ComputerName $computer -Credential $creds -Filter "DeviceID='c:'"
        $size_before = [math]::round($CdriveObj_before.Size/1GB, 0)
        $free_before = [math]::round($CdriveObj_before.FreeSpace/1GB, 0)
        $Percentage_before =[math]::Round((($free_before/$size_before))*100,1)
        
        $log += "Current C Drive Utilization is $Percentage_before"

        if([int]$Percentage_before -le 10)
        {
            Write-Host "Above"
            $log += "C Drive Utilizaiton is above threshold limit"
        }
        else
        {
           Write-Host "Below"
            $log += "C Drive Utilizaiton is below threshold limit"
			
"Action taken : cleared Windows\temp, \windows\softwaredistribution, \windows\users\, RecycleBin, \windows]ccmcache\ files

Current status : Now the free space is $Percentage_before%, Hence resolving the incident"  | Out-File "D:\Incident\C_Drive\$INCNumber\logs\close_notes.txt" -Append

        }
}
catch
{
    Write-Host "Unable to fetch the C Drive space"
    $log += "Unable to fetch the C Drive space"
}

$log += $temp_Content 

$log += "Script Execution Ends $(timestamp)"
$log += "-----------------"

$log | Add-Content "$log_path\log.txt"


Post Execution:

if(Process[OpName].scriptOutput.indexOf("Below")>=0)
{
  Process.ReturnCode=3
  Process.Unitilzation="Low"
  Process.ReturnMessage="The C Drive utilised is below threshold, Resolving the Ticket"
}
else if(Process[OpName].scriptOutput.indexOf("Above")>=0)
{
  Process.ReturnCode=5
  Process.ReturnMessage ="The C Drive utilization is above the threshold limit"
  Process.Unitilzation="High"
}
else if(Process[OpName].scriptOutput.indexOf("Unable to fetch the C Drive space")>=0)
{
  Process.ReturnCode=7
  Process.ReturnMessage="Unable to fetch the C Drive space"
}
else
{
Process.ReturnCode=-1
Process.returnMessage = "Fatal Error"
}


14.Update Ticket

Pre Execution:

Process.PostDelay = "<request><entry><work_notes>Post Deletion of file from Windows Temp, Software Distribution, CCM Cache, RecycleBin, User Profiles who are not active in the past 90 days the C Drive Utilizaed is still above threshold.</work_notes></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  if(Process[OpName].HTTPResponseContent.indexOf("incident_state\":\"")>=0)
  {
	Process.ReturnCode=0;
	Process.ReturnMessage="Ticket updated successfully ";
  }
  else
  {
	Process.ReturnCode=-1;
	Process.ReturnMessage="Error occurred while updating ticket";
  }
}
else
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Failure occurred while updating ticket"
}

15.Script

Inline:

param($hostname,
$INCNumber,
$RDPUser,
$RDPPass)
<#
$hostname = "sendvmt01"
$INCNumber = "aaaaaaaa"
$RDPUser = "svc-itpam"
$RDPPass = "Hs2n7MB7o3JmB2G4"
#>
######################Variables##########################
$id=1;
$statusHash=@{}

function timestamp{
    Get-Date -Format "dd_MMM_yyyy_HH:mm:ss tt"
}

$log_path = "D:\Incident\C_Drive\$INCNumber\logs\"

$log=@()
$log += "-----------------"
$log += "Health Check Script Execution Started at $(timestamp)"


$password =  $RDPPass | ConvertTo-SecureString -AsPlainText -Force
$winCred = New-Object pscredential -ArgumentList ($RDPUser , $password)

######################Folder Creation#####################
$filePath="D:\Incident\C_Drive\$INCNumber\Windows_Health_Check"
If(!(test-path $filePath))
{
      New-Item -ItemType Directory -Force -Path $filePath
}

$Report = @()
$ping,$uptime,$AVGProc,$mem,$vol,$storageUti,$sccm,$bits,$wmi,$port,$up = ""
$statusCount=0;
try
{
    if((Test-Connection $hostName -Count 4 -Quiet) -and (New-PSSession -ComputerName "$hostName" -Credential $winCred))
    {
        $ping = "Pingable"
        #cpu utilization
        $log += "Ping Status is $ping"
        $AVGProc = Invoke-Command -ComputerName $hostName -Credential $winCred -ScriptBlock{gwmi win32_processor |  Measure-Object -property LoadPercentage -Average | Select Average -ErrorAction SilentlyContinue}
        $log += "Average CPU is $($AVGProc.Average)"

        # memory usage
        $mem = Invoke-Command -ComputerName $hostName -Credential $winCred -ScriptBlock{gwmi -Class win32_operatingsystem  | Select-Object @{Name = "MemoryUsage"; Expression = {“{0:N2}” -f ((($_.TotalVisibleMemorySize - $_.FreePhysicalMemory)*100)/ $_.TotalVisibleMemorySize) }} -ErrorAction SilentlyContinue}
        $log += "Average MEM is $($mem.MemoryUsage)"
        # disk space free
        $vol = Invoke-Command -ComputerName $hostName -Credential $winCred  -ScriptBlock{gwmi win32_logicaldisk -filter "drivetype=3" | select @{name =  "DriveName" ;Expression = {$_.deviceid}},@{name = "TotalSize";Expression = {($_.size/1GB).ToString(0.00)+"GB"}},@{name = "Utilized";Expression = {(($_.size-$_.freespace)/1GB).ToString(0.00)+"GB"}}, @{name = "FreeSpace" ;Expression = {($_.freespace/1GB).ToString(0.00)+"GB"}} -ErrorAction SilentlyContinue}
        $storageUti = $vol[0].FreeSpace
        $log += "C: Drive Space is $storageUti"
        #SCCM Client - CcmExec 
        $sccm = Invoke-Command -ComputerName $hostName -Credential $winCred -ScriptBlock{Get-Service -Name "CcmExec"}
        $log += "SSCM Service Status is $($sccm.Status)"
        $wmi = Invoke-Command -ComputerName $hostName -Credential $winCred -ScriptBlock{Get-Service  -Name "Winmgmt"}
        $log += "WMI Service Status is $($wmi.Status)"
        #Port Check
        $port = test-netconnection -computername $hostName -Port 3389 | Select -ExpandProperty TcpTestSucceeded  
        $log += "Port Status is $port"
        #uptime Check
        $up = Get-WmiObject Win32_OperatingSystem -ComputerName $hostName -Credential $winCred
        $rawtime = $up.ConvertToDateTime($up.LastBootUpTime)
        $formatedtime = (Get-Date)-$rawtime
        $uptime = "$($formatedtime.Days) Days,$($formatedtime.Hours) Hours,$($formatedtime.Minutes) Minutes,$($formatedtime.Seconds) Seconds"
        
        #Close Ps-Session
        Get-PSSession | Remove-PSSession
     }
     else
     {
         write-host "Skipping $hostName"
         if(Test-Connection $hostName -Count 2 -Quiet)
         {
             $ping = "Unable to take a Remote Session"
             Write-Host "Unable to take a Remote Session"
         }
         else
         {
             $ping = "Non-Pingable"
         }
          
     }
     $usrName = $winCred.UserName
     $execDate=get-date -Format "MM_dd_yyyy_HH_mm"  
}
catch
{
    write-Host "Failed to Generate Report"
}
$log += "Writing the HTML File"
try
{
$body = @()
$body +="<HTML>
<HEAD><TITLE>SERVER STATUS</TITLE></HEAD>
<BODY>

<h1><b>
            <center>Server Health Check Status</center>
        </b></h1>
    <table width=100% border=1>
<tr> <br> </tr>
        <tr>
            <th class='label' colspan=2> Server Baseline Information </th>
        </tr>
        <tr>
            <td><b> Host Name </b></td>
            <td>$HOSTNAME</td>
        </tr>
        <tr>
            <td><b> Executed at </b></td>
            <td>$execDate</td>
        </tr>           
        <tr>
            <td><b> Executed By </b></td>
            <td>$usrName</td>
        </tr>   
        <tr>
            <td><b> Ping Status </b></td>"
        if($ping -like "Pingable")
        {
            $body += "<td><b style='color:#20A608'>Pingable</b></td>"
        }
        else
        {
            $body += "<td><b style='color:#FF3C33'>Server is Not Reachable</b></td>"
        }
        $body += "</tr>
        <tr>
            <td><b> Uptime </b></td>
            <td>$uptime</td>
        </tr>
        <tr>
        <td><b> Average CPU </b></td>"  
 
        if($($AVGProc.Average) -le 80)
        {
           $body += "<td><b style='color:#20A608'>$($AVGProc.Average) %</b></td>"
        }
        else
        {
           $body += "<td><b style='color:#FF3C33'>$($AVGProc.Average) %</b></td>"
        } 
        $body += "</td>  
        </tr>
        <tr>
            <td><b> Average MEM </b></td>"
        if($($mem.MemoryUsage) -le 80)
        {
           $body += "<td><b style='color:#20A608'>$($mem.MemoryUsage) %</b></td>"
        }
        else
        {
           $body += "<td><b style='color:#FF3C33'>$($mem.MemoryUsage) %</b></td>"
        }
        $body +="</tr>
        <tr>
            <td><b> C: Drive Space </b></td>"
        if($($storageUti) -ge 80)
        {
           $body += "<td><b style='color:#20A608'>$($storageUti)</b></td>"
        }
        else
        {
           $body += "<td><b style='color:#FF3C33'>$($storageUti)</b></td>"
        }

        $body += "</tr>
        <tr>
            <td><b>SCCM Agent Service Status </b></td>"
         if($($sccm.status) -eq "Running")
        {
           $body += "<td><b style='color:#20A608'>$($sccm.status)</b></td>"
        }
        else
        {
           $body += "<td><b style='color:#FF3C33'>$($sccm.status)</b></td>"
        }
        $body +="</tr>
        <tr>
        <td><b>WMI Service Status </b></td>"
        if($($wmi.status) -eq "Running")
        {
           $body += "<td><b style='color:#20A608'>$($wmi.status)</b></td>"
        }
        else
        {
           $body += "<td><b style='color:#FF3C33'>$($wmi.status)</b></td>"
        }
        $body +="</tr>
        <tr>
            <td><b>RDP Port </b></td>"
        if($port)
        {
           $body += "<td><b style='color:#20A608'>$port</b></td>"
        }
        else
        {
           $body += "<td><b style='color:#FF3C33'>$port</b></td>"
        }
        
        $body +="</tr>
 </body></html>"
 
$body | Out-File "D:\Incident\C_Drive\$INCNumber\Windows_Health_Check\HealthCheckReport.html"
$log += "HTML File created successfully"
}
catch
{
$log += "Failed to write HTML File"
write-host "Failed to write HTML File"
}

try
{
$wkhtmltopdf = "D:\wkhtmltopdf\bin\wkhtmltopdf.exe"
$var = "-q"
$html = "D:\Incident\C_Drive\$INCNumber\Windows_Health_Check\HealthCheckReport.html"
$pdf = "D:\Incident\C_Drive\$INCNumber\Windows_Health_Check\HealthCheckReport.pdf"
& $wkhtmltopdf $var $html $pdf
$log += "Successfully Converted HTML file to PDF Format"
Write-Host "Successfully Converted HTML file to PDF Format"
}
catch
{
$log += "Failed to convert the HTML file to PDF"
Write-Host "Failed to convert the HTML file to PDF"
}

$log += "Health Check Script Execution Completed $(timestamp)"
$log += "-----------------"

$log | Add-Content $log_path\log.txt 

Post Execution:

if(Process[OpName].scriptOutput.indexOf("Successfully Converted HTML file to PDF Format")>=0)
{
  Process.ReturnCode=5
  Process.ReturnMessage ="Successfully Converted HTML file to PDF Format"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to Generate Report")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to Generate Report"
}
else if(Process[OpName].scriptOutput.indexOf("Unable to take a Remote Session")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Unable to take a Remote Session"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to write HTML File")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to write HTML File"
}
else if(Process[OpName].scriptOutput.indexOf("Failed to convert the HTML file to PDF")>=0)
{
  Process.ReturnCode=-1
  Process.ReturnMessage="Failed to convert the HTML file to PDF"
}
else
{
Process.ReturnCode=-1
Process.returnMessage = "Fatal Error"
}


14.Ticket Update

Pre Execution:

Process.HealthCheck = "<request><entry><work_notes>"+Process.ReturnMessage+"</work_notes></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  if(Process[OpName].HTTPResponseContent.indexOf("incident_state\":\"")>=0)
  {
	Process.ReturnCode=0;
	Process.ReturnMessage="Ticket updated successfully ";
  }
  else
  {
	Process.ReturnCode=-1;
	Process.ReturnMessage="Error occurred while updating ticket";
  }
}
else
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Failure occurred while updating ticket"
}

15.Script

Inline:

Param($INC_Number)
$file = Get-ChildItem "D:\Incident\C_Drive\$($INC_Number)\Windows_Health_Check\*.pdf"

if($file)
{
write-Host "PDF File Exist"
$fullPath = $file.FullName 
$fileName = $file.Name
$fullPath
$fileName 
}
else
{write-host "PDF file doesnot exist"}

Post Execution:

if(Process[OpName].scriptOutput.indexOf("PDF File Exist")>=0)
{
Process.ReturnCode = 0
Process.ReturnMessage = "PDF Generated successfully"
Process.Data = Process[OpName].scriptOutput
}
else if(Process[OpName].scriptOutput.indexOf("PDF file doesnot exist")>=0)
{
Process.ReturnCode = 2
Process.ReturnMessage = "PDF file doesnot exist."

}
else if(Process.Utilization = "Low")
{
Process.ReturnMessage = "Utilization is Below Threshold"
Process.ReturnCode = 5
}
else
{
Process.ReturnCode=2
Process.ReturnMessage = "Fatal Error."
}


15.Ticket Update

Pre Execution:

Process.dat=Process.PDF_Report.scriptOutput.split('\n')
Process.fname=Process.dat[2]
Process.pdffile=Process.dat[1]

//Process.putURL= "https://"+Process.Instance+".service-now.com/api/now/attachment/file?table_name=change_task&table_sys_id="+Process.Sys_Id+"&file_name="+Process.fname


Process.putURL= "https://"+Process.SnowEnv+".service-now.com/api/now/attachment/file?table_name=incident&table_sys_id="+Process.Sys_Id+"&file_name="+Process.fname
//Process.payload = "<request><entry><assigned_to>d2f5f34bdb5efb8036c73c9b7c961900</assigned_to><work_notes>Automation Acknowledged. Ref ID:"+ Process.RuntimeROID+"</work_notes><state>2</state></entry></request>"


Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="Created" && Process[OpName].HTTPResponseStatusCode==201 )
{
  Process.ReturnCode=0;
  Process.ReturnMessage="PDF updated successfully."


}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent

}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Error occurred while uploading PDF file to Service Now."
  
}

16.Script

Inline:

Param($INC_Number)
Get-Content "D:\Incident\C_Drive\$INC_Number\logs\close_notes.txt" 

Post Execution:

if(Process[OpName].scriptOutput.indexOf("What is the Issue :")>=0)
{
Process.ReturnCode = 0
Process.ReturnMessage = "Close Codes file retrived successfully"
Process.Data = Process[OpName].scriptOutput
}
else if(Process[OpName].scriptOutput.indexOf("Get-Content")>=0)
{
Process.ReturnCode = 2
Process.ReturnMessage = "Failed to update the CLose codee"
}
else
{
Process.ReturnCode=2
Process.ReturnMessage = "Fatal Error."
}


17.Ticket Update

Pre Execution:

Process.putURL="https://"+Process.SnowEnv+".service-now.com/api/now/v2/table/incident/"+Process.Sys_Id+"?sysparm_fields=incident_state"

if(Process.Unitilzation == "Low")
{
Process.Final = "<request><entry><close_code>Solved (Permanently)</close_code><u_knowledge_issues>true</u_knowledge_issues><u_knowledge_issue_type>2</u_knowledge_issue_type><close_notes>"+Process.PDF_Report_1.scriptOutput+"</close_notes><u_comments>Ticekt Resolved Successfully</u_comments><u_repeat_incident>No</u_repeat_incident><work_notes>The C Drive Utilization is  below the threshold level, hence resolving the ticket.</work_notes><incident_state>6</incident_state></entry></request>"
Process.ReturnCode = 9
}
else 
{
Process.Final = "<request><entry><assigned_to></assigned_to><work_notes>THe C Drive Utilization is still above threshold level, hence routing the ticket to Windows Queue. </work_notes><assignment_group>d32d41c5dbe73e00d41dd3cb5e96194f</assignment_group></entry></request>"
}


Post Execution:

 if(Process.ReturnCode==9)
{
  Process.ReturnCode=9;
  Process.ReturnMessage="Upload the KB"
}
else if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  if(Process[OpName].HTTPResponseContent.indexOf("incident_state\":\"")>=0)
  {
	Process.ReturnMessage="Ticket resolved successfully ";
	Process.ReturnCode=0;
  }
  else
  {
	Process.ReturnMessage="Error occurred while  resolving ticket";
	Process.ReturnCode=-1;
  }
}
else
{
  Process.ReturnCode=-1;
  Process.ReturnMessage="Failure occurred while resolving ticket"
}

18.Ticket Update

Pre Execution:


//Process.putURL= "https://"+Process.Instance+".service-now.com/api/now/attachment/file?table_name=change_task&table_sys_id="+Process.Sys_Id+"&file_name="+Process.fname


Process.putURL= "https://"+Process.SnowEnv+".service-now.com/api/now/attachment/file?table_name=incident&table_sys_id="+Process.Sys_Id+"&file_name="+Process.docname
//Process.payload = "<request><entry><assigned_to>d2f5f34bdb5efb8036c73c9b7c961900</assigned_to><work_notes>Automation Acknowledged. Ref ID:"+ Process.RuntimeROID+"</work_notes><state>2</state></entry></request>"


Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="Created" && Process[OpName].HTTPResponseStatusCode==201 )
{
  Process.ReturnCode=1;
  Process.ReturnMessage="PDF updated successfully."


}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent

}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent
  
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Error occurred while uploading PDF file to Service Now."
  
}

19.Fatal Ticket Update

Pre Execution:

Process.FatalErrorPayLoad ="<request><entry><assigned_to></assigned_to><work_notes>Automation Failed, Routing the Ticket to Windows Assignmenet Group</work_notes><assignment_group>d32d41c5dbe73e00d41dd3cb5e96194f</assignment_group></entry></request>"
