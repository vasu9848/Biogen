1. Get Ticket

Pre Execution:

Process.url = "https://"+Process.Instance+".service-now.com/api/now/table/sc_task?number="+Process.Number

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=0;
  Process.ReturnMessage="Ticket details fetched successfully"
  Process.Output=Process[OpName].HTTPResponseContent
  
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Failure fetching ticket details"
}

2. Second Operator (Read)

Inline:

var str =Process.Output
var start=str.indexOf('[')+2;
var end=str.indexOf(']')-1;
var res = str.substring(start,end);
var out1= res.split(',');
for(var i=0;i < out1.length;i++)
{
  out1[i]=out1[i].replace(/\"/g,"");
  if(out1[i].indexOf('active')>=0)
  {Process.active=(out1[i].split(':'))[1]}
  else if(out1[i].indexOf('sys_id')>=0)
  {Process.Sys_Id=(out1[i].split(':'))[1]}
  else if(out1[i].indexOf('description')>=0)
  {Process.description=(out1[i].split(':'))[1]}
  else if(out1[i].indexOf('state')>=0)
  {Process.state=(out1[i].split(':'))[1]}
  out1[i]=(out1[i].split(':'))[1]
}

Post Execution:

if(Process.active)
{
  Process.ReturnCode=0;
  Process.ReturnMessage="Ticket is active.";
}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Ticket is inactive.";
}

3.Ticket Update

Pre Execution:

Process.putURL="https://"+Process.Instance+".service-now.com/api/now/table/sc_task/"+Process.Sys_Id+""
Process.payload = "<request><entry><assigned_to>d2f5f34bdb5efb8036c73c9b7c961900</assigned_to><work_notes>Automation Acknowledged. Ref ID:"+ Process.RuntimeROID+"</work_notes><state>2</state></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=0;
  Process.ReturnMessage="Ticket worknotes updated successfully."

}
else if(Process[OpName].Reason.indexOf('non-success') >= 0)
{
	Process.ReturnCode =2;
    Process.ReturnMessage = Process[OpName].HTTPResponseContent
}
else if(Process[OpName].Reason.indexOf('failure') >= 0)
{
	Process.ReturnCode =2;
    Process.ReturnMessage = Process[OpName].HTTPResponseContent
}
else
{
    Process.ReturnCode=2;
    Process.ReturnMessage="Failure updating ticket details."

}

4.Linux Operator

Pre Execution:

Process.ansibleCommand = "ansible-playbook ~/server_snapshot_creation/main.yml -e ' env="+Process.env+" acc_name="+Process.account_1+" az="+Process.available_zone+" ins="+Process.Instance_id+" Retention_Period="+Process.Retention_Period+"'"

Post Execution:

if((Process[OpName].Resout.indexOf('Instance is available') >= 0) &&(Process[OpName].Resout.indexOf('Created AMI snapshot is in available state') >= 0)&&(Process[OpName].Resout.indexOf('AMI snapshot created successfully') >= 0)){
Process.AMIOut=Process.Create_AMI.Resout.split('AMI snapshot created successfully:')
Process.AMI=Process.AMIOut[1]
Process.amiid=Process.AMI.replace(/\"\S*/g, "")
Process.splitvar=Process.amiid.split('\n')
Process.Finalout=Process.splitvar[0]
  Process.ReturnCode = 0
  Process.ReturnMessage = "AMI id" + Process.FinalOut + " " + "created succesfully." 

}
else if(Process[OpName].Resout.indexOf('Instance is not available. So, stopping the process.') >= 0){
  Process.ReturnCode = 2
  Process.ReturnMessage = "Instance is not available. So, stopping the process."
}
else if(Process[OpName].Resout.indexOf('Created AMI snapshot is not in available state.') >= 0){
  Process.ReturnCode = 2
  Process.ReturnMessage = "Created AMI snapshot is not in available state."
}
else if(Process[OpName].Resout.indexOf('Failed to fetch Account ID.') >= 0){
  Process.ReturnCode = 2
  Process.ReturnMessage = "Failed to fetch Account ID."
}
else if(Process[OpName].Resout.indexOf('Failed to create Backup job.') >= 0){
  Process.ReturnCode = 2
  Process.ReturnMessage = "Failed to create Backup job."
}
else if(Process[OpName].Resout.indexOf('Backup job failed') >= 0){
  Process.ReturnCode = 2
  Process.ReturnMessage = "Backup job failed"
}
else if(Process[OpName].Resout.indexOf('Backup job ID fetch failed') >= 0){
  Process.ReturnCode = 2
  Process.ReturnMessage = "Backup job ID fetch failed"
}
else if(Process[OpName].Resout.indexOf('permission denied') >= 0){
  Process.ReturnCode = 2
  Process.ReturnMessage = "Permission denied by the server."
}
else if(Process[OpName].Resout.indexOf("the field 'args' has an invalid value") >= 0){
  Process.ReturnCode = 2
  Process.ReturnMessage = "Error occured while executing playbook."
}
else
{
	Process.ReturnCode = 3
	Process.ReturnMessage = "Some error occurred while executing the Ansible Playbook."

}


5.Ticket Update

Pre Execution:

Process.putURL="https://"+Process.Instance+".service-now.com/api/now/table/sc_task/"+Process.Sys_Id+""
Process.payload = "<request><entry><u_automation_result>Successful</u_automation_result><work_notes>"+Process.ReturnMessage+"</work_notes><state>3</state></entry></request>"

Post Execution:

if(Process[OpName].HTTPResponseReasonPhrase=="OK" && Process[OpName].HTTPResponseStatusCode==200 )
{
  Process.ReturnCode=1;
  Process.ReturnMessage="Ticket worknotes updated successfully"

  
}else if(Process[OpName].Reason.indexOf('non-success') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent

}
else if(Process[OpName].Reason.indexOf('failure') >= 0){
	Process.ReturnCode =2;
  Process.ReturnMessage = Process[OpName].HTTPResponseContent

}
else
{
  Process.ReturnCode=2;
  Process.ReturnMessage="Failure updating ticket details"

}

6.Fatal Ticket Update

Pre Execution:

Process.putURL="https://"+Process.Instance+".service-now.com/api/now/table/sc_task/"+Process.Sys_Id+""
Process.FatalErrorPayLoad ="<request><entry><u_automation_result>Unsuccessful</u_automation_result><state>1</state><assigned_to></assigned_to><assignment_group>4e22c6b4db806f00fa0f8e5c29961927</assignment_group><work_notes>"+Process.ReturnMessage+ ".Hence routing the ticket</work_notes></entry></request>"
//Process.FatalErrorPayLoad ="<request><entry><assignment_group>d32d41c5dbe73e00d41dd3cb5e96194f</assignment_group><assigned_to></assigned_to><work_notes>"+Process.ReturnMessage+ "</work_notes></entry></request>"


Ansible Playbook

server_snapshot_creation/main.yml

---
- name: Snapshot creation for AMI EC2 backup instance
  hosts: localhost
  gather_facts: no
  # connection: local
  tasks:
    - set_fact:
        aws_account_name: "{{ acc_name }}"
        aws_environment: "{{ env[0] }}"
        #aws_hostname: "{{ host }}"
        aws_instance: "{{ ins }}"
        az: "{{ az }}"
        ami_id: ""
        retention_period : "{{ Retention_Period }}"
        role: ia-role
      tags: variables

    - name: Run Kion Stak command to get the access key and secret key
      command: kion --profile nonprod stak --l {{ aws_account_name }} --car {{ role }} -p
      register: non_prod_stak_output
      when: aws_environment != "P"

    - debug:
        msg: "{{ non_prod_stak_output }}"
      when: aws_environment != "P"

    - name: Run Kion Stak command to get the access key and secret key - Prod
      command: kion --profile prod stak --l {{ aws_account_name }} --car {{ role }} -p
      register: prod_stak_output
      when: aws_environment == "P"

    - debug:
        msg: "{{ prod_stak_output }}"
      when: aws_environment == "P"

    - name: setting up the variables of non Prod access key and secret key
      set_fact:
        AWS_ACCESS_KEY_ID: "{{ non_prod_stak_output.stdout_lines[0].split('export AWS_ACCESS_KEY_ID=')[1] }}"
        AWS_SECRET_ACCESS_KEY: "{{ non_prod_stak_output.stdout_lines[1].split('export AWS_SECRET_ACCESS_KEY=')[1] }}"
        AWS_SESSION_TOKEN: "{{ non_prod_stak_output.stdout_lines[2].split('export AWS_SESSION_TOKEN=')[1] }}"
      when: aws_environment != "P"

    - name: setting up the variables of Prod access key and secret key - Prod
      set_fact:
        AWS_ACCESS_KEY_ID: "{{ prod_stak_output.stdout_lines[0].split('export AWS_ACCESS_KEY_ID=')[1] }}"
        AWS_SECRET_ACCESS_KEY: "{{ prod_stak_output.stdout_lines[1].split('export AWS_SECRET_ACCESS_KEY=')[1] }}"
        AWS_SESSION_TOKEN: "{{ prod_stak_output.stdout_lines[2].split('export AWS_SESSION_TOKEN=')[1] }}"
      when: aws_environment == "P"

    - name: Configure AWS CLI with Access Key and Secret Key
      shell: |
        aws configure set aws_access_key_id {{ AWS_ACCESS_KEY_ID }}
        aws configure set aws_secret_access_key {{ AWS_SECRET_ACCESS_KEY }}
        aws configure set aws_session_token {{ AWS_SESSION_TOKEN }}
        aws configure set region {{ az }}
      register: set_aws_configure
    - name: Check if the instance exists
      command: aws ec2 describe-instances --instance-ids {{ ins }} --query "Reservations[*].Instances[*].[InstanceId]" --output text
      register: instance_check
      ignore_errors: yes
    - debug:
        msg: "{{ instance_check }}"

    - debug:
        msg: "Instance is available. So, proceeding for the AMI Creation."
      when: instance_check.stderr == ""

    - fail:
        msg: "Instance is not available. So, stopping the process."
      when: instance_check.stderr != ""

    #- name: Running date command to get the AMI name
    #  shell: date +"%d-%m-%Y-%H-%M-%S" | awk '{print $0}'
    #  register: date_out
    #  when: instance_check.stderr == ""

    #- set_fact:
    #    ami_name: "AWS-BackUp-{{ ins }}-{{ date_out.stdout }}"
    #  when: instance_check.stderr == ""

    #- debug:
    #    msg: "{{ ami_name }}"
    #  when: instance_check.stderr == ""

    - name: Checking the account ID
      command: aws sts get-caller-identity --query "Account" --output text
      register: account_id
      when: instance_check.rc == 0 and instance_check.stderr == ""
    
    - fail:
        msg: "Failed to fetch Account ID."
      when: account_id.stderr != ""

    - name: Display Account ID result
      debug:
        msg: "{{ account_id.stdout }}"
      when: instance_check.rc == 0 and instance_check.stderr == ""

    - name: Create an AMI from the instance
      command: aws backup start-backup-job --backup-vault-name turbot-backup-vault --resource-arn arn:aws:ec2:{{ az }}:{{ account_id.stdout }}:instance/{{ ins }} --iam-role-arn arn:aws:iam::{{ account_id.stdout }}:role/AWSBackupServiceRole --lifecycle DeleteAfterDays={{ Retention_Period }} --query "BackupJobId" --output text
      register: backupjob_id
      when: instance_check.rc == 0 and instance_check.stderr == ""

    - fail:
        msg: "Failed to create Backup job."
      when: backupjob_id.stderr != "" 

    - name: Display Backup job ID result
      debug:
        msg: "{{ backupjob_id.stdout }}"
      when: instance_check.rc == 0 and instance_check.stderr == ""

    - name: Wait for Backup job id to become completed
      command: aws backup describe-backup-job --backup-job-id {{ backupjob_id.stdout }} --query "State" --output text
      register: Backup_status
      until: Backup_status.stdout == "COMPLETED"
      retries: 60
      delay: 60
      when: backupjob_id | length > 0
      
    - fail:
        msg: "Backup job failed"
      when: Backup_status.stdout != "COMPLETED"

    #- name: Set backupjob ID variable
    #  set_fact:
    #    backupjob_id: "{{ backupjob.stdout | regex_search('BackupJobId: ') }}"
    #  when: backupjob is defined

    #- name: Display Backup job ID result
    #  debug:
    #    msg: "{{ backupjob_id }}"
    #  when: backupjob_id | length > 0

    - name: Fetch the AMI ID
      command: aws backup describe-backup-job --backup-job-id {{ backupjob_id.stdout }} --query "RecoveryPointArn" --output text
      register: ami_result
      when: backupjob_id | length > 0

    - fail:
        msg: "Backup job ID fetch failed"
      when: ami_result.stderr != "" 
    
    - name: Display AMI ID result
      debug:
        msg: "{{ ami_result.stdout }}"
      when: backupjob_id | length > 0

    - name: Set backupjob ID variable
      set_fact:
        ami_id: "{{ ami_result.stdout | regex_search('ami.*') }}"        
        #ami_id: "{{ ami_result.stdout | regex_search('snapshot.([a-zA-Z0-9-_.,@]+)') }}"   
      when: backupjob_id | length > 0

    - name: Display AMI ID result
      debug:
        msg: "{{ ami_id }}"
      when: backupjob_id | length > 0
    
    - name: Wait for Snapshot id to become completed
      command: aws ec2 describe-images --image-ids {{ ami_id }} --query "Images[*].State" --output text
      register: snapshot_status
      until: snapshot_status.stdout == "available"
      retries: 20
      delay: 60
      when: ami_id | length > 0

    #- fail:
    #    msg: "AMI Snapshot failed"
    #  when: backupjob_id.stdout != "available"

    #- name: Tag the AMI with retention period
    #  ec2_tag:
    #      resource: "{{ ami_id }}"
    #      tags:
    #        Retention_Period: "{{ retention_period }}"
          
    - debug:
        msg: "Created AMI snapshot {{ ami_id }} with retention period of {{ retention_period }} days"

    - debug:
        msg: "Created AMI snapshot is in available state."
      when: snapshot_status.stdout == "available"

    - fail:
        msg: "Created AMI snapshot is not in available state."
      when: snapshot_status.stdout != "available"

    - debug:
        msg: "AMI snapshot created successfully: {{ ami_id }}"
      when: snapshot_status.stdout == "available"
